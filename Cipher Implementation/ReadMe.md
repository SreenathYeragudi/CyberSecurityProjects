## GOAL:
  1.implement a binary version of the Vigenère polyalphabetic substitution cipher.
  
  2.implement a stream cipher that uses a linear congruential keystream generator and a hashed key as a seed.
  
  
  3.perate as a block cipher that will shuffle pairs of bytes within each block based on the keystream and will apply cipher block chaining (CBC) between blocks.

## BINARY CIPHER
  ### HOW IT WORKS
      Each row of the grid contains the alphabet shifted by one position to the left compared to the previous row. 
      To encrypt, We:
        1.Find the row indexed by the plaintext letter.
        2.Find the column indexed by the next character of the key
        3.The ciphertext letter is the intersection. The key is repeated to make it the same length as the message.
  ### files that will be used:
      (vencrypt and vdecrypt)
      (samples files)
  ### Testing and Running
  
      Testing:
        To know if the code works:
          ->The user calls vencrypt and passes a keyfile, plaintext file of choice, and cipher file from choice
          -> After this is called, the cipher file holds the cipher code (symbols) that the plaintext was encrypted to
          -> To then test if the encryption worked, we call vdecrypt on the same files and see if we got the same plaintext as we had 
          before
          -> If the plaintext values changed, then it DID NOT WORK
          -> If the plaintext values after calling vencrypt and vdecrypt didn't change then it WORKED
          
      Running Vencrypt:
      
        ./vencrypt keyfile plaintext ciphertext
        
        keyfile= is a file that has a password saved in it, can be any type of file extension, usually (.txt)
        
        plaintext= any of the files from the samples 
        
        cipherfile= create a file of any extension to hold the cipher text (usually use .txt or .enc excpet for .jpg)
        
        Example keyfile inputs:
          -> 'password#1'
          -> 'monkeyanddog'
          -> 'Your name is'
      Running Vdecrypt:
      
        ./vencrypt keyfile ciphertext plaintext
        
        keyfile= use the same keyfile you used for vencrypt
        
        plaintext= use the same plaintext file from the samples
        
        cipherfile= use the same cipherfile used in the vencrypt
        
## STREAM CIPHER

  ### HOW IT WORKS
    The keystream generator is a pseudorandom number generator, and the seed will be derived from the password. 
    You will always see the same sequence of numbers for the same seed.

    To implement this cipher, We will:

    (a) Implement a linear congruential generator
    This is a trivial formula that is described here (Links to an external site.). 
    This is one of the best-known and widely-used pseudorandom number generators. Each pseudorandom number is function of the previous one and defined as:

    Xn+1 = aXn + c mod m

    where:
    Xn+1 is the next pseudorandom # in the sequence
    Xn is the number before that in the sequence
    m is a modulus. We will be working only on bytes in this assignment, so we will use 256 for the modulus (since that is 28 and will produce a range of values that fit within a byte).

    The values a and c are magic parameters. Certain values were found to produce better sequences of data. 
    We will use the same parameters that are used in ANSI C, C99, and many other places:

    Modulus, m = 256 (1 byte)
    Multiplier, a = 1103515245
    Increment, c = 12345

    Implementing this generator is only three lines of code!

    By using a well-known formula, your output should be the same regardless of the programming language or operating system you use.

    (b) Convert the password to a seed
    The seed for a pseudorandom number generator is just a number. 
    For this program, instead of asking users to use a number as a key, you will let them use a textual password. 
    You will then apply a hash function to this password to create a seed for the keystream generator.

    To create the seed, we will use a hash function that works well and is easy to implement. 
    This is the sbdm hash that is used in gawk, the sbdm database, Berkeley DB, and many other places. 
  

    static unsigned long
    sdbm(unsigned char *str) {
      unsigned long hash = 0;
      int c;
      while (c = *str++)
        hash = c + (hash << 6) + (hash << 16) - hash;
      return hash;
    }
    You should be able to translate it to whatever language you’re programming in pretty easily. 
    This implementation is also three lines of code!

    As with the previous step, this implementation should ensure that your output will be the same regardless of the programmer, programming language, or operating system.

    (c) Apply the stream cipher
    The ciphertext is generated byte by byte and is simply:

          ciphertexti = plaintexti ⊕ keytexti

    Each byte of plaintext is XORed with the next byte from the keystream generator to produce a byte of ciphertext. 
    Because applying an exclusive-or of the same key a second time undoes the first exclusive-or, you only need to implement one command.
    
### files that will be used:
    scrypt
    
### Testing and Running:

    To know if the code works:
          ->The user calls scrypt and passes a password, plaintext file of choice, and cipher file from choice
          -> After this is called, the cipher file holds the cipher code (symbols) that the plaintext was encrypted to
          -> To then test if the encryption worked, we call scrypt on the same files and see if we got the same plaintext as we had 
          before
          -> If the plaintext values changed, then it DID NOT WORK
          -> If the plaintext values after calling vencrypt and vdecrypt didn't change then it WORKED
    
    TO ENCRYPT AND DECRYPT WE USE THE SAME FILE!!!
    
    To encrypt:
      
      ./scrypt password plaintext ciphertext
      
      password= a string written into the command line arguement (Example: monkey01)
      plaintext= choice from samples
      ciphertext= file of any extension that stores the cipher text
      
    To decrypt:
    
    ./scrypt password ciphertext plaintext
    
      password= same password as before
      plaintext= same plaintext as before
      ciphertext= same ciphertext as before
      
## BLOCK CIPHER

  ### HOW IT WORKS

    We modify the stream cipher above to have it operate on 16-byte blocks instead of bytes. This turns it into a form of block cipher. A block cipher normally uses multiple iterations (rounds) through an SP-network (substitutions & permutations) to add confusion & diffusion. Confusion refers to changing bit values as a function of the key so that each bit of the ciphertext is determined by several parts of the key. Diffusion refers to the property that a change in one bit of plaintext will result in many bits of the ciphertext changing (about half).

      In this implementation, we will not use multiple rounds of an SP network. Instead, we will keep the mechanisms of the stream cipher in place but enhance it in two ways: cipher block chaining and shuffling bytes within the block.

      Padding
      Block ciphers work on a block (a group of bytes) of data at a time. In our case, we will be processing 16-byte blocks.

      Not every file is an exact multiple of 16 bytes so we may encounter a partial block at the end. To support this, every block cipher needs to support padding, which is the mechanism for adding extra bytes to fill the block. Padding must be added in such a way that we can detect and remove the padding when decrypting a message.

      The way I will implement padding is by adding between 1 and 16 extra bytes at the end of the file. Each byte of the padding data is a number that tells you how many bytes were added. This is a technique that allows you to know how much padding needs to be removed when decrypting and writing the plaintext output.

      In the case that the file was an exact multiple of 16 bytes, we add an entire extra block of padding. Otherwise, we would never know if we had padding. Simply looking at the last byte of the last block of the file will tell us how much padding to ignore.

      Here are a few examples. In the first, the text "I am done." takes up 10 bytes so we have 6 bytes left over. Each of those bytes will contain a pad byte with a value of 6. Note that this is not the ASCII character 6 but the number 6.


      In this example, we have the text "This is the end". It takes up 15 bytes, so we need to add one byte of padding. This padding byte contains the value 1.


      In the final example, we have the text "This is the end." with a period at the end. This message takes up exactly 16 bytes. Because of this, we need to add an extra block filled with bytes containing the number 16.




      When i decode the message, i will need to remove the padding.

      We will not use multiple rounds of an SP network. Instead, we will keep the mechanisms of the stream cipher in place but enhance it in two ways: cipher block chaining and byte shuffling within a block (a simple form of permutations).

      Cipher block chaining
      Stream ciphers have no diffusion. The change of a bit in plaintext will generally affect only that bit in ciphertext. We will add diffusion across the output by adding cipher block chaining (CBC). With cipher block chaining, we exclusive-or the previous block with the next block.




      Byte shuffling
      Confusion is roughly determined by the seed and the pseudorandom output of the keystream generator in this implementation, but we will enhance the degree of confusion by shuffling bytes of the block.

      We will use the key to determine which sets of bytes in the block to exchange (swap). For each 16-byte block, do the following:

      for (i=0; i < blocksize; i=i+1)
          first = key[i] & 0xf (lower 4 bits of the keystream)
          second = (key[i] >> 4) & 0xf (top 4 bits of the keystream)
          swap(block[first], block[second]) (exchange the bytes)

      Cipher operation
      The flow of the cipher is the following:

      Start by creating an initialization vector (IV) for applying CBC to the first block. This will be the first 16 bytes read from the keystream generator. These bytes will not be used for anything else.

      Then, for each 16-byte plaintext_block i:

      If it is the last block, add padding. This will be an amount from 1 through 16 bytes
      (e.g., finish up a block or add a new block). The padding is added before any encryption or shuffling takes place.

      Apply CBC: temp_blocki = plaintext_blocki ⊕ ciphertext_blocki-1. Use the initialization vector if this is the first block (i=0).

      Read 16 bytes from the keystream.

      Shuffle the bytes based on the keystream data.

      ciphertext_blocki = temp_blocki ⊕ keystreami.

      Write ciphertext_blocki.
      
 ### files we will use
    sbencrypt
    sbdecrypt
      
 ### TESTING AND RUNNING
 
    To know if the code works:
          ->The user calls sbencrypt and passes a password, plaintext file of choice, and cipher file from choice
          -> After this is called, the cipher file holds the cipher code (symbols) that the plaintext was encrypted to
          -> To then test if the encryption worked, we call sbdecrypt on the same files and see if we got the same plaintext as we had 
          before
          -> If the plaintext values changed, then it DID NOT WORK
          -> If the plaintext values after calling vencrypt and vdecrypt didn't change then it WORKED
    
    
      
    To encrypt:
      ./sbencrypt password plaintext ciphertext
      
      password= a string written into the command line arguement (Example: monkey01)
      plaintext= choice from samples
      ciphertext= file of any extension that stores the cipher text
      
    To decrypt:
    
      ./sbdecrypt password ciphertext plaintext
      
      password= same password as before
      plaintext= same plaintext as before
      ciphertext= same ciphertext as before

    

